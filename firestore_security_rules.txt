// Updated Firestore Security Rules for Enhanced Chat Management
// This is a diff/enhancement to existing rules, not a complete replacement

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuth() { 
      return request.auth != null; 
    }
    
    function isMember(thread) { 
      return isAuth() && request.auth.uid in thread.members; 
    }
    
    function isValidThreadUpdate(oldData, newData) {
      // Allow only specific fields to be updated
      return newData.diff(oldData).changedKeys().hasOnly([
        'hiddenFor', 'visibilityCutoff', 'unreadCounts', 'lastMessage', 
        'lastMessageTime', 'updatedAt', 'members', 'joinedAt', 'name', 
        'avatarUrl', 'groupDescription', 'lastRecreatedAt'
      ]);
    }
    
    function canUpdateVisibilityCutoff(oldData, newData) {
      // For 1-1 chats: user can only update their own visibilityCutoff
      return !oldData.isGroup && (
        // User is only updating their own cutoff
        (newData.visibilityCutoff.keys().hasOnly([request.auth.uid]) &&
         newData.visibilityCutoff.size() == oldData.visibilityCutoff.size() + 1) ||
        // No changes to visibilityCutoff
        newData.visibilityCutoff == oldData.visibilityCutoff
      );
    }
    
    function canUpdateHiddenFor(oldData, newData) {
      // User can only add/remove themselves from hiddenFor
      let oldHidden = oldData.hiddenFor;
      let newHidden = newData.hiddenFor;
      let userUid = request.auth.uid;
      
      return (
        // User adding themselves to hiddenFor
        (userUid in newHidden && !(userUid in oldHidden) && 
         newHidden.removeAll([userUid]) == oldHidden.removeAll([userUid])) ||
        // User removing themselves from hiddenFor  
        (!(userUid in newHidden) && userUid in oldHidden &&
         newHidden == oldHidden.removeAll([userUid])) ||
        // No changes to hiddenFor
        newHidden == oldHidden
      );
    }

    // Chat threads collection
    match /chat_threads/{threadId} {
      // Read access: only members can read
      allow read: if isMember(resource.data);
      
      // Delete: not allowed (use soft delete via hiddenFor)
      allow delete: if false;
      
      // Create: validate thread structure
      allow create: if isAuth() && (
        // 1-1 chat: exactly 2 members, sorted order
        (!request.resource.data.isGroup && 
         request.resource.data.members.size() == 2 &&
         request.resource.data.members == request.resource.data.members.toSet() &&
         request.resource.data.members[0] < request.resource.data.members[1] &&
         request.auth.uid in request.resource.data.members) ||
        // Group chat: >= 2 members, user must be included
        (request.resource.data.isGroup && 
         request.resource.data.members.size() >= 2 &&
         request.auth.uid in request.resource.data.members)
      );
      
      // Update: strict validation
      allow update: if isMember(resource.data) && 
        isValidThreadUpdate(resource.data, request.resource.data) &&
        canUpdateHiddenFor(resource.data, request.resource.data) &&
        (
          // 1-1 chat specific rules
          (!resource.data.isGroup && canUpdateVisibilityCutoff(resource.data, request.resource.data)) ||
          // Group chat rules (more permissive for group management)
          resource.data.isGroup
        );
    }

    // Messages subcollection  
    match /chat_threads/{threadId}/messages/{messageId} {
      // Read: only thread members can read messages
      allow read: if isMember(get(/databases/$(database)/documents/chat_threads/$(threadId)).data);
      
      // Create: only thread members can send messages
      allow create: if isMember(get(/databases/$(database)/documents/chat_threads/$(threadId)).data) &&
        // Validate message structure
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.keys().hasOnly(['senderId', 'createdAt', 'content']) &&
        // Ensure server timestamp (optional - can be enforced via Cloud Functions)
        request.resource.data.createdAt == request.time;
      
      // Update/Delete: not allowed (messages are immutable)
      allow update, delete: if false;
    }
    
    // Users collection (existing rules remain, just adding context)
    match /users/{userId} {
      // Allow users to read their own profile and profiles of chat members
      allow read: if isAuth() && (
        request.auth.uid == userId ||
        // Allow reading profiles of users you have chat threads with
        exists(/databases/$(database)/documents/chat_threads) // Simplified for example
      );
      
      // Allow users to update their own profile
      allow write: if isAuth() && request.auth.uid == userId;
    }
  }
}

/*
KEY SECURITY ENHANCEMENTS:

1. **Granular Field Updates**: Users can only update specific fields (hiddenFor, visibilityCutoff, etc.)

2. **Self-Management**: Users can only add/remove themselves from hiddenFor, only set their own visibilityCutoff

3. **Thread Integrity**: 1-1 threads must have exactly 2 sorted members, groups must have â‰¥2 members

4. **Message Immutability**: Messages cannot be updated or deleted after creation

5. **Server Timestamp Enforcement**: Messages must use server timestamp for createdAt

6. **Member Access Control**: Only thread members can read messages and thread details

7. **Soft Delete Only**: Hard deletion of threads is prevented, forcing use of hiddenFor

MIGRATION NOTES:
- Deploy these rules AFTER updating client code to use new field structure
- Test thoroughly in Firestore emulator before production deployment
- Consider gradual rollout with feature flags
*/
