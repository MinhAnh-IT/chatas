import 'dart:async';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/notification_model.dart';

class NotificationRemoteDataSource {
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;

  // Stream controllers ƒë·ªÉ x·ª≠ l√Ω th√¥ng b√°o
  final StreamController<NotificationModel> _foregroundMessageController =
      StreamController<NotificationModel>.broadcast();
  final StreamController<NotificationModel> _backgroundMessageController =
      StreamController<NotificationModel>.broadcast();

  Stream<NotificationModel> get onForegroundMessage =>
      _foregroundMessageController.stream;
  Stream<NotificationModel> get onBackgroundMessage =>
      _backgroundMessageController.stream;

  /// Kh·ªüi t·∫°o Firebase Messaging
  Future<void> initialize() async {
    // Y√™u c·∫ßu quy·ªÅn th√¥ng b√°o
    NotificationSettings settings = await _firebaseMessaging.requestPermission(
      alert: true,
      announcement: false,
      badge: true,
      carPlay: false,
      criticalAlert: false,
      provisional: false,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('User granted permission');
    } else if (settings.authorizationStatus ==
        AuthorizationStatus.provisional) {
      print('User granted provisional permission');
    } else {
      print('User declined or has not accepted permission');
    }

    // L·∫Øng nghe th√¥ng b√°o khi app ƒëang m·ªü (foreground)
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');

      if (message.notification != null) {
        print('Message also contained a notification: ${message.notification}');

        final notificationModel = NotificationModel.fromFirebaseMessage({
          'notification': {
            'title': message.notification?.title,
            'body': message.notification?.body,
            'imageUrl':
                message.notification?.android?.imageUrl ??
                message.notification?.apple?.imageUrl,
          },
          'data': message.data,
        });

        _foregroundMessageController.add(notificationModel);
      }
    });

    // L·∫Øng nghe khi app ƒë∆∞·ª£c m·ªü t·ª´ background
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      print('A new onMessageOpenedApp event was published!');
      print('Message data: ${message.data}');

      final notificationModel = NotificationModel.fromFirebaseMessage({
        'notification': {
          'title': message.notification?.title,
          'body': message.notification?.body,
          'imageUrl':
              message.notification?.android?.imageUrl ??
              message.notification?.apple?.imageUrl,
        },
        'data': message.data,
      });

      _backgroundMessageController.add(notificationModel);
    });
  }

  /// L·∫•y FCM token
  Future<String?> getFCMToken() async {
    try {
      String? token = await _firebaseMessaging.getToken();
      print('FCM Token: $token');
      return token;
    } catch (e) {
      print('Error getting FCM token: $e');
      return null;
    }
  }

  /// L·∫•y th√¥ng b√°o ban ƒë·∫ßu (khi app ƒë∆∞·ª£c m·ªü t·ª´ terminated state)
  Future<NotificationModel?> getInitialMessage() async {
    try {
      RemoteMessage? initialMessage = await _firebaseMessaging
          .getInitialMessage();

      if (initialMessage != null) {
        print('App was opened from a terminated state via notification');
        print('Initial message data: ${initialMessage.data}');

        return NotificationModel.fromFirebaseMessage({
          'notification': {
            'title': initialMessage.notification?.title,
            'body': initialMessage.notification?.body,
            'imageUrl':
                initialMessage.notification?.android?.imageUrl ??
                initialMessage.notification?.apple?.imageUrl,
          },
          'data': initialMessage.data,
        });
      }
      return null;
    } catch (e) {
      print('Error getting initial message: $e');
      return null;
    }
  }

  /// Subscribe v√†o topic (n·∫øu c·∫ßn)
  Future<void> subscribeToTopic(String topic) async {
    try {
      await _firebaseMessaging.subscribeToTopic(topic);
      print('Subscribed to topic: $topic');
    } catch (e) {
      print('Error subscribing to topic: $e');
    }
  }

  /// Unsubscribe t·ª´ topic
  Future<void> unsubscribeFromTopic(String topic) async {
    try {
      await _firebaseMessaging.unsubscribeFromTopic(topic);
      print('Unsubscribed from topic: $topic');
    } catch (e) {
      print('Error unsubscribing from topic: $e');
    }
  }

  /// G·ª≠i token l√™n server (c·∫ßn implement endpoint tr√™n backend)
  Future<void> sendTokenToServer(String token) async {
    try {
      // TODO: Implement API call to your backend
      // Example:
      // final response = await http.post(
      //   Uri.parse('YOUR_BACKEND_URL/api/fcm-tokens'),
      //   headers: {'Content-Type': 'application/json'},
      //   body: json.encode({'token': token}),
      // );
      print('Token sent to server: $token');
    } catch (e) {
      print('Error sending token to server: $e');
    }
  }

  /// G·ª≠i th√¥ng b√°o ƒë·∫øn user c·ª• th·ªÉ th√¥ng qua FCM token ƒë∆∞·ª£c l∆∞u trong Firestore
  Future<void> sendNotificationToUser({
    required String userId,
    required NotificationModel notification,
  }) async {
    try {
      print('üîî Preparing to send notification to user: $userId');
      print('   Title: ${notification.title}');
      print('   Body: ${notification.body}');

      // L·∫•y FCM token c·ªßa user t·ª´ Firestore
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get();

      if (!userDoc.exists) {
        print('‚ùå User not found: $userId');
        return;
      }

      final userData = userDoc.data()!;
      final fcmToken = userData['fcmToken'] as String?;

      if (fcmToken == null || fcmToken.isEmpty) {
        print('‚ùå FCM token not found for user: $userId');
        return;
      }

      // T·∫°o notification data ƒë·ªÉ g·ª≠i
      final notificationData = {
        'to': fcmToken,
        'notification': {
          'title': notification.title,
          'body': notification.body,
        },
        'data': {
          ...notification.data,
          'click_action': 'FLUTTER_NOTIFICATION_CLICK',
        },
      };

      // TODO: ·ªû ƒë√¢y c·∫ßn implement vi·ªác g·ª≠i qua FCM server
      // Hi·ªán t·∫°i ch·ªâ log ra ƒë·ªÉ demo
      print('üì± Notification data prepared for FCM:');
      print('   Token: ${fcmToken.substring(0, 20)}...');
      print('   Data: $notificationData');

      // Note: ƒê·ªÉ g·ª≠i th·ª±c s·ª±, c·∫ßn backend server v·ªõi admin SDK
      // ho·∫∑c s·ª≠ d·ª•ng HTTP POST t·ªõi FCM API v·ªõi server key

      print('‚úÖ Notification prepared successfully for user: $userId');
    } catch (e) {
      print('‚ùå Error sending notification to user: $e');
      throw Exception('Failed to send notification to user: $e');
    }
  }

  void dispose() {
    _foregroundMessageController.close();
    _backgroundMessageController.close();
  }
}
